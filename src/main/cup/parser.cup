package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.files.SymbolTableGenerator;
import java.util.*;
import lyc.compiler.TreeParser.*;
import lyc.compiler.files.*;
class Parser;

action code
{:
    public NodoSintactico nExp,nTerm,nFactor,nAsig,nComp,nSentence,nIf,nSentences,nWhile,nWrite,nRead,nInit,nListId,nReorderStatement,nReorderL,nListIdPartial,nReorderLE,nBoolExp,nVarList,nVarListS, nNegativeCalculation;
    public IntermediateCodeGenerator gen = new IntermediateCodeGenerator();
    public ArrayList<String> listaIds;
:}
// Terminals
terminal ASSIG;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal OPEN_PARENTHESES;
terminal CLOSE_PARENTHESES;
terminal OPEN_BRACE;
terminal CLOSE_BRACE;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal EQUALS;
terminal GREATER_THAN;
terminal LESS_THAN;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal READ;
terminal WRITE;
terminal STRING_LITERAL;
terminal INTEGER_CONSTANT;
terminal FLOAT_CONSTANT;
terminal IDENTIFIER;
terminal ASSIGNATION;
terminal ARITHMETIC_ASSIG;
terminal INIT;
terminal FLOAT_TYPE;
terminal INT;
terminal STRING;
terminal COLON;
terminal COMMA;
terminal COMMENT;
terminal OR;
terminal AND;
terminal NOT;
terminal REORDER;
terminal NEGATIVE_CALCULATION;


// Non Terminals
non terminal  program;
non terminal NodoSintactico sentence;
non terminal NodoSintactico sentences;
non terminal NodoSintactico assignment;
non terminal  if_stmt;
non terminal  while_loop;
non terminal  write_stmt;
non terminal  read_stmt;
non terminal NodoSintactico expression;
non terminal NodoSintactico comparison;
non terminal NodoSintactico term;
non terminal NodoSintactico factor;
non terminal  NodoSintactico init_block;
non terminal NodoSintactico variable_declaration;
non terminal NodoSintactico variable_declaration_list;
non terminal NodoSintactico identifier_list;
non terminal  type;
non terminal  assign_operator;
non terminal  NodoSintactico reorder_stmt;
non terminal  reorder_list;
non terminal  reorder_list_elements;
non terminal  bool_expression;
non terminal  negative_calculation_stmt;
non terminal  float_expression_list;


// Start Symbol Definition
start with program;

//

program ::= sentences
          {:
                SymbolTableGenerator generator = new SymbolTableGenerator();
                generator.generate();
                gen.addTree(nSentences);
                gen.generate();
          :};
sentences ::= sentence:snt
    {:
        nSentences = nSentence;
        RESULT = nSentence;
    :};
sentences ::= sentence:snt sentences:rest
    {:
        nSentences = NodoSintactico.crearNodo(";", snt, rest);
        RESULT = nSentences;
    :};


sentence ::= assignment {: nSentence=nAsig; RESULT=nSentence; :}
           | if_stmt {: nSentence=nIf; RESULT=nSentence; :}
           | while_loop {: nSentence=nWhile; RESULT=nSentence; :}
           | init_block {: nSentence = nInit; RESULT=nSentence; :}
           | read_stmt {: nSentence = nRead; RESULT=nSentence; :}
           | write_stmt {: nSentence=nWrite; RESULT=nSentence; :}
           | reorder_stmt {: nSentence = nReorderStatement; RESULT=nSentence; :}
           | identifier_list {: nSentence = nListId; RESULT=nSentence; :}
           | COMMENT
           ;


init_block ::= INIT OPEN_BRACE variable_declaration_list CLOSE_BRACE
             {: System.out.println("Initialization block");
                nInit=NodoSintactico.crearNodo("INIT",nVarListS,null);
                RESULT=nInit;
             :};

// ASSIGNMENT
assignment ::= IDENTIFIER:id assign_operator expression {:
    System.out.println("Assignment to ID: " + id);

    // Crear nodo de asignación
    nAsig = NodoSintactico.crearNodo(":=", NodoSintactico.crearHoja(id), nExp);
    // Verificación y agregación a tabla de símbolos
    if (!SymbolTableGenerator.isVariableDefined(id.toString().trim())) {
        SymbolTableGenerator.addVariable(id.toString().trim(), "-");
    }
:};


assignment ::= IDENTIFIER:id assign_operator negative_calculation_stmt {:
    nAsig = NodoSintactico.crearNodo("=", NodoSintactico.crearHoja(id), nNegativeCalculation);

    System.out.println("Assignment result of NegativeCalculation to ID: " + id);
    if (!SymbolTableGenerator.isVariableDefined(id.toString().trim())) {
        SymbolTableGenerator.addVariable(id.toString().trim(), "-");
    }
:};

assign_operator ::= ASSIGNATION
                  | ARITHMETIC_ASSIG
                  | ASSIG
                  ;


// IF
if_stmt ::= IF OPEN_PARENTHESES comparison:cmp CLOSE_PARENTHESES OPEN_BRACE sentences:sen CLOSE_BRACE
            {: System.out.println("If statement with block parsed");
               nIf=NodoSintactico.crearNodo("IF",cmp,sen);
               RESULT = nIf;
            :};
if_stmt ::= IF OPEN_PARENTHESES comparison:cmp CLOSE_PARENTHESES OPEN_BRACE sentences:sen1 CLOSE_BRACE ELSE OPEN_BRACE sentences:sen2 CLOSE_BRACE
            {: System.out.println("If-Else statement parsed");
               nIf=NodoSintactico.crearNodo("IF",cmp,NodoSintactico.crearNodo("CUERPO",sen1,sen2));
               RESULT = nIf;
            :};

write_stmt ::= WRITE OPEN_PARENTHESES STRING_LITERAL:str CLOSE_PARENTHESES
             {:
                System.out.println("Write statement with string literal: " + str);
                nWrite=NodoSintactico.crearNodo("WRITE",NodoSintactico.crearHoja(str),null);
                RESULT = nWrite;
             :};

write_stmt ::= WRITE OPEN_PARENTHESES IDENTIFIER:id CLOSE_PARENTHESES
            {:
                System.out.println("Write statement with variable: " + id);
                nWrite=NodoSintactico.crearNodo("WRITE",NodoSintactico.crearHoja(id),null);
                RESULT = nWrite;
            :};

while_loop ::= WHILE OPEN_PARENTHESES comparison:cmp CLOSE_PARENTHESES OPEN_BRACE sentences:sens CLOSE_BRACE
             {: System.out.println("While with condition");
                nWhile=NodoSintactico.crearNodo("WHILE",cmp,NodoSintactico.crearNodo("CUERPO",sens,null));
              :};

read_stmt ::= READ OPEN_PARENTHESES IDENTIFIER:id CLOSE_PARENTHESES
            {:
                System.out.println("Read statement with variable: "+ id);
                nRead=NodoSintactico.crearNodo("READ",NodoSintactico.crearHoja(id),null);
                RESULT = nRead;
            :};

// Reorder
reorder_stmt ::= REORDER OPEN_PARENTHESES OPEN_BRACKET reorder_list:list CLOSE_BRACKET COMMA bool_expression:bool COMMA INTEGER_CONSTANT:int_const CLOSE_PARENTHESES
                {:
                  System.out.println("Reorder statement detectada.");
                  System.out.println("Lista de elementos: " + list);
                  System.out.println("Valor de BOOL: " + bool);
                  System.out.println("Valor de INTEGER_CONSTANT: " + int_const);
                  nReorderStatement = NodoSintactico.crearNodo("REORDER",NodoSintactico.crearNodo("PARAMS",nReorderL,NodoSintactico.crearNodo("PARAMS",nBoolExp,NodoSintactico.crearHoja(int_const))),null);
                  RESULT = nReorderStatement;
                :};


reorder_list ::= reorder_list_elements:list
               {:
                    System.out.println("Lista de elementos procesados: " + list);
                    nReorderL = nReorderLE;
                    RESULT = list;
                    System.out.println("Resultado final de la lista: " + RESULT);

               :};


reorder_list_elements ::= expression:exp
                        {:
                            System.out.println("Elemento agregado: " + exp);
                            nReorderLE=exp;
                            RESULT = exp;
                        :}
                        | expression:exp COMMA reorder_list_elements:list
                        {:
                            System.out.println("Sumando: " + exp + " A lista: " + list);
                            nReorderLE=NodoSintactico.crearNodo(",",exp,nReorderLE);
                            RESULT = exp + ", " + list;
                        :};

negative_calculation_stmt ::= NEGATIVE_CALCULATION OPEN_PARENTHESES float_expression_list:exp CLOSE_PARENTHESES
                {:
                    List<String> expList = (List<String>) exp;

                    nNegativeCalculation = NodoSintactico.crearNodo("negativeCalculation", null, null);

                    nNegativeCalculation.setIzquierdo(NodoSintactico.createBalancedTree(expList.subList(0, expList.size() / 2)));
                    nNegativeCalculation.setDerecho(NodoSintactico.createBalancedTree(expList.subList(expList.size() / 2, expList.size())));

                    RESULT = nNegativeCalculation;
                :};

float_expression_list ::= FLOAT_CONSTANT:exp
                        {:
                            // Crear una lista para almacenar la expresión
                            List<String> expList = new ArrayList<>();
                            expList.add(exp.toString());  // Añadir el valor de exp a la lista
                            RESULT = expList;
                        :};

float_expression_list ::= IDENTIFIER:id
                        {:
                            // Crear una lista para almacenar la expresión
                            List<String> expList = new ArrayList<>();
                            expList.add(id.toString());  // Añadir el valor de id a la lista
                            RESULT = expList;
                        :};

float_expression_list ::= FLOAT_CONSTANT:exp COMMA float_expression_list:list
                        {:
                            // Acumular los elementos de la lista
                            List<String> expList = (List<String>) list;  // Convertimos 'list' en una lista
                            expList.add(exp.toString());  // Añadir el valor de exp a la lista
                            RESULT = expList;  // Retornamos la lista acumulada
                        :};

float_expression_list ::= IDENTIFIER:id COMMA float_expression_list:list
                        {:
                            // Acumular los elementos de la lista
                            List<String> expList = (List<String>) list;  // Convertimos 'list' en una lista
                            expList.add(id.toString());  // Añadir el valor de id a la lista
                            RESULT = expList;  // Retornamos la lista acumulada
                        :};


variable_declaration_list ::= variable_declaration:v variable_declaration_list:vl {: nVarListS = NodoSintactico.crearNodo("L",v,vl); RESULT=nVarListS; :};
//variable_declaration_list ::= COMMENT variable_declaration_list:vl {: nVarListS=vl; RESULT=nVarListS; :};
variable_declaration_list ::= variable_declaration  {: nVarListS = nVarList; RESULT = nVarList; :};
variable_declaration ::= identifier_list:list COLON type:type {:
    System.out.println("[Var Declaration] " + list + " : " + type);
    for (String id : (ArrayList<String>) listaIds) {
        id = id.trim();
        if (!SymbolTableGenerator.isVariableDefined(id)) {
            SymbolTableGenerator.addVariable(id, type.toString());
        }
    }
    nVarList= NodoSintactico.crearNodo(":",list,NodoSintactico.crearHoja(type.toString()));
    RESULT=nVarList;
:};


identifier_list ::= IDENTIFIER:id
{:
    System.out.println("Id: " + id);
    listaIds = new ArrayList<>();
    listaIds.add(id.toString().trim());
    nListId = NodoSintactico.crearHoja(id);
    RESULT = nListId;
:};


identifier_list ::= identifier_list:list COMMA IDENTIFIER:id
{:
    System.out.println("List: " + list + ", ID: " + id);
    ((List<String>) listaIds).add(id.toString().trim());

    nListId = NodoSintactico.crearNodo(",", list, NodoSintactico.crearHoja(id));

    RESULT = nListId;
:};

type ::= FLOAT_TYPE {: System.out.println("Float"); RESULT = "float"; :}
      | INT {: System.out.println("Int"); RESULT = "int"; :}
      | STRING {: System.out.println("String"); RESULT = "string"; :};

comparison ::= expression:exp1 GREATER_THAN expression:exp2 {:
    nComp = NodoSintactico.crearNodo(">", exp1, exp2);
    RESULT = nComp;
:};

comparison ::= expression:exp1 LESS_THAN expression:exp2 {:
    nComp = NodoSintactico.crearNodo("<", exp1, exp2);
    RESULT = nComp;
:};

comparison ::= expression:exp1 EQUALS expression:exp2 {:
    nComp = NodoSintactico.crearNodo("==", exp1, exp2);
    RESULT = nComp;
:};

// Comparison with AND
comparison ::= comparison:comp AND expression:exp1 GREATER_THAN expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo(">", exp1, exp2);
    nComp = NodoSintactico.crearNodo("AND", comp, comp2);
    RESULT = nComp;
:};

comparison ::= comparison:comp AND expression:exp1 LESS_THAN expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo("<", exp1, exp2);
    nComp = NodoSintactico.crearNodo("AND", comp, comp2);
    RESULT = nComp;
:};

comparison ::= comparison:comp AND expression:exp1 EQUALS expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo("==", exp1, exp2);
    nComp = NodoSintactico.crearNodo("AND", comp, comp2);
    RESULT = nComp;
:};

// Comparison with OR
comparison ::= comparison:comp OR expression:exp1 GREATER_THAN expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo(">", exp1, exp2);
    nComp = NodoSintactico.crearNodo("OR", comp, comp2);
    RESULT = nComp;
:};

comparison ::= comparison:comp OR expression:exp1 LESS_THAN expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo("<", exp1, exp2);
    nComp = NodoSintactico.crearNodo("OR", comp, comp2);
    RESULT = nComp;
:};

comparison ::= comparison:comp OR expression:exp1 EQUALS expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo("==", exp1, exp2);
    nComp = NodoSintactico.crearNodo("OR", comp, comp2);
    RESULT = nComp;
:};

// Comparison with NOT
comparison ::= NOT expression:exp1 GREATER_THAN expression:exp2 {:
    NodoSintactico comp = NodoSintactico.crearNodo(">", exp1, exp2);
    nComp = NodoSintactico.crearNodo("NOT", comp, null);
    RESULT = nComp;
:};

comparison ::= NOT expression:exp1 LESS_THAN expression:exp2 {:
    NodoSintactico comp = NodoSintactico.crearNodo("<", exp1, exp2);
    nComp = NodoSintactico.crearNodo("NOT", comp, null);
    RESULT = nComp;
:};

comparison ::= NOT expression:exp1 EQUALS expression:exp2 {:
    NodoSintactico comp = NodoSintactico.crearNodo("==", exp1, exp2);
    nComp = NodoSintactico.crearNodo("NOT", comp, null);
    RESULT = nComp;
:};

comparison ::= expression:exp1 {:
    System.out.println("Comparison: " + exp1);
    nComp=exp1;
    RESULT = nComp;
:};

expression ::= term:exp {: nExp = nTerm;
                            RESULT = nExp;
                         :};
expression ::=  expression:exp1 PLUS term:exp2 {:
                System.out.println(exp1 + " + " + exp2);
                nExp = NodoSintactico.crearNodo("+",(NodoSintactico)nExp,(NodoSintactico)nTerm);
                RESULT = nExp;
            :};
expression ::= expression:exp1 SUB term:exp2 {:
                System.out.println(exp1 + " - " + exp2);
                nExp = NodoSintactico.crearNodo("-",(NodoSintactico)nExp,(NodoSintactico)nTerm);
                RESULT = nExp;
               :};

term ::= factor:exp {: nTerm = nFactor;
                        RESULT = nTerm;
                    :};
term ::= term:exp1 MULT factor:exp2 {:
            System.out.println(exp1 + " * " + exp2);
            nTerm = NodoSintactico.crearNodo("*",(NodoSintactico)nTerm,(NodoSintactico)nFactor);
            RESULT = nTerm;
         :};
term ::= term:exp1 DIV factor:exp2 {:
           System.out.println(exp1 + " / " + exp2);
           nTerm = NodoSintactico.crearNodo("/",(NodoSintactico)nTerm,(NodoSintactico)nFactor);
           RESULT = nTerm;
         :};

factor ::= IDENTIFIER:id {: System.out.println("Id: " + id); nFactor = NodoSintactico.crearHoja(id); RESULT=nFactor;:};
factor ::= INTEGER_CONSTANT:constant {:
            System.out.println("Constant: " + constant);
            String value = constant.toString();
            SymbolTableGenerator.addConstant(value, "int", value);
            nFactor = NodoSintactico.crearHoja(constant);
            RESULT=nFactor;
            :};

factor ::= FLOAT_CONSTANT:constant {:
            System.out.println("Constant: " + constant);
            String value = constant.toString();
            SymbolTableGenerator.addConstant(value, "float", value);
            nFactor = NodoSintactico.crearHoja(constant);
            RESULT=nFactor;
            :};

factor ::= STRING_LITERAL:literal {:
            System.out.println("String literal: " + literal);
            String value = literal.toString();
            SymbolTableGenerator.addConstant(value, "string", value);
            nFactor = NodoSintactico.crearHoja(literal);
            RESULT=nFactor;
            :};

factor ::= OPEN_PARENTHESES expression:exp CLOSE_PARENTHESES {: System.out.println("Expression: (" + exp + ")"); nFactor = nExp; RESULT=nFactor; :};

bool_expression ::= INTEGER_CONSTANT:integer_constant
        {:
          if (!integer_constant.equals("0") && !integer_constant.equals("1")) {
            throw new Exception("Invalid boolean constant: " + integer_constant);
          }
          nBoolExp = NodoSintactico.crearHoja(integer_constant);
          RESULT = integer_constant;
        :};