package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.files.SymbolTableGenerator;
import java.util.*;
import lyc.compiler.TreeParser.*;
import lyc.compiler.files.*;
class Parser;

action code
{:
    public NodoSintactico nExp,nTerm,nFactor,nAsig,nComp,nSentence,nIf,nSentences,nWhile,nWrite,nRead,nInit;
    public IntermediateCodeGenerator gen = new IntermediateCodeGenerator();
:}
// Terminals
terminal ASSIG;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal OPEN_PARENTHESES;
terminal CLOSE_PARENTHESES;
terminal OPEN_BRACE;
terminal CLOSE_BRACE;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal EQUALS;
terminal GREATER_THAN;
terminal LESS_THAN;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal READ;
terminal WRITE;
terminal STRING_LITERAL;
terminal INTEGER_CONSTANT;
terminal FLOAT_CONSTANT;
terminal IDENTIFIER;
terminal ASSIGNATION;
terminal ARITHMETIC_ASSIG;
terminal INIT;
terminal FLOAT_TYPE;
terminal INT;
terminal STRING;
terminal COLON;
terminal COMMA;
terminal COMMENT;
terminal OR;
terminal AND;
terminal NOT;
terminal REORDER;
terminal NEGATIVE_CALCULATION;


// Non Terminals
non terminal  program;
non terminal NodoSintactico sentence;
non terminal NodoSintactico sentences;
non terminal NodoSintactico assignment;
non terminal  if_stmt;
non terminal  while_loop;
non terminal  write_stmt;
non terminal  read_stmt;
non terminal NodoSintactico expression;
non terminal NodoSintactico comparison;
non terminal NodoSintactico term;
non terminal NodoSintactico factor;
non terminal  init_block;
non terminal  variable_declaration;
non terminal  variable_declaration_list;
non terminal  identifier_list;
non terminal  type;
non terminal  assign_operator;
non terminal  reorder_stmt;
non terminal  reorder_list;
non terminal  reorder_list_elements;
non terminal  bool_expression;
non terminal  negative_calculation_stmt;
non terminal  float_expression_list;


// Start Symbol Definition
start with program;

//

program ::= sentences
          {:
                SymbolTableGenerator generator = new SymbolTableGenerator();
                generator.generate();
                gen.addTree(nSentences);
                gen.generate();
          :};
sentences ::= sentence:snt
    {:
        nSentences = nSentence;
        RESULT = nSentence;
    :};
sentences ::= sentence:snt sentences:rest
    {:
        nSentences = NodoSintactico.crearNodo(";", snt, rest);
        RESULT = nSentences;
    :};


sentence ::= assignment {: nSentence=nAsig; RESULT=nSentence; :}
           | if_stmt {: nSentence=nIf; RESULT=nSentence; :}
           | while_loop {: nSentence=nWhile; RESULT=nSentence; :}
           | init_block
           | read_stmt {: nSentence = nRead; RESULT=nSentence; :}
           | write_stmt {: nSentence=nWrite; RESULT=nSentence; :}
           | reorder_stmt
           | negative_calculation_stmt
           | COMMENT
           ;


init_block ::= INIT OPEN_BRACE variable_declaration_list CLOSE_BRACE
             {: System.out.println("Initialization block");
                //nInit=NodoSintactico.crearNodo();
                //RESULT=nInit;
             :};

// ASSIGNMENT
assignment ::= IDENTIFIER:id assign_operator expression {:
    System.out.println("Assignment to ID: " + id);

    // Crear nodo de asignación
    nAsig = NodoSintactico.crearNodo(":=", NodoSintactico.crearHoja(id), nExp);
    // Verificación y agregación a tabla de símbolos
    if (!SymbolTableGenerator.isVariableDefined(id.toString().trim())) {
        SymbolTableGenerator.addVariable(id.toString().trim(), "-");
    }
:};


assignment ::= IDENTIFIER:id assign_operator negative_calculation_stmt {:
    System.out.println("Assignment result of NegativeCalculation to ID: " + id);
    if (!SymbolTableGenerator.isVariableDefined(id.toString().trim())) {
        SymbolTableGenerator.addVariable(id.toString().trim(), "-");
    }
:};

assign_operator ::= ASSIGNATION
                  | ARITHMETIC_ASSIG
                  | ASSIG
                  ;


// IF
if_stmt ::= IF OPEN_PARENTHESES comparison:cmp CLOSE_PARENTHESES OPEN_BRACE sentences:sen CLOSE_BRACE
            {: System.out.println("If statement with block parsed");
               nIf=NodoSintactico.crearNodo("IF",cmp,sen);
               RESULT = nIf;
            :};
if_stmt ::= IF OPEN_PARENTHESES comparison:cmp CLOSE_PARENTHESES OPEN_BRACE sentences:sen1 CLOSE_BRACE ELSE OPEN_BRACE sentences:sen2 CLOSE_BRACE
            {: System.out.println("If-Else statement parsed");
               nIf=NodoSintactico.crearNodo("IF",cmp,NodoSintactico.crearNodo("CUERPO",sen1,sen2));
               RESULT = nIf;
            :};

write_stmt ::= WRITE OPEN_PARENTHESES STRING_LITERAL:str CLOSE_PARENTHESES
             {:
                System.out.println("Write statement with string literal: " + str);
                nWrite=NodoSintactico.crearNodo("WRITE",NodoSintactico.crearHoja(str),null);
                RESULT = nWrite;
             :};

write_stmt ::= WRITE OPEN_PARENTHESES IDENTIFIER:id CLOSE_PARENTHESES
            {:
                System.out.println("Write statement with variable: " + id);
                nWrite=NodoSintactico.crearNodo("WRITE",NodoSintactico.crearHoja(id),null);
                RESULT = nWrite;
            :};

while_loop ::= WHILE OPEN_PARENTHESES comparison:cmp CLOSE_PARENTHESES OPEN_BRACE sentences:sens CLOSE_BRACE
             {: System.out.println("While with condition");
                nWhile=NodoSintactico.crearNodo("WHILE",cmp,NodoSintactico.crearNodo("CUERPO",sens,null));
              :};

read_stmt ::= READ OPEN_PARENTHESES IDENTIFIER:id CLOSE_PARENTHESES
            {:
                System.out.println("Read statement with variable: "+ id);
                nRead=NodoSintactico.crearNodo("READ",NodoSintactico.crearHoja(id),null);
                RESULT = nRead;
            :};

// Reorder
reorder_stmt ::= REORDER OPEN_PARENTHESES OPEN_BRACKET reorder_list:list CLOSE_BRACKET COMMA bool_expression:bool COMMA INTEGER_CONSTANT:int_const CLOSE_PARENTHESES
                {:
                  System.out.println("Reorder statement detectada.");
                  System.out.println("Lista de elementos: " + list);
                  System.out.println("Valor de BOOL: " + bool);
                  System.out.println("Valor de INTEGER_CONSTANT: " + int_const);
                  RESULT = "reorder(" + list + "," + bool + "," + int_const + ")";
                :};


reorder_list ::= reorder_list_elements:list
               {:
                    System.out.println("Lista de elementos procesados: " + list);
                    RESULT = list;
                    System.out.println("Resultado final de la lista: " + RESULT);

               :};


reorder_list_elements ::= expression:exp
                        {:
                            System.out.println("Elemento agregado: " + exp);
                            RESULT = exp;
                        :}
                        | expression:exp COMMA reorder_list_elements:list
                        {:
                            System.out.println("Sumando: " + exp + " A lista: " + list);
                            RESULT = exp + ", " + list;
                        :};

negative_calculation_stmt ::= NEGATIVE_CALCULATION OPEN_PARENTHESES float_expression_list:exps CLOSE_PARENTHESES
                {:
                    System.out.println("Negative Calculation detectada con expresiones: " + exps);
                    RESULT = "negativeCalculation(" + exps + ")";
                :};

float_expression_list ::= FLOAT_CONSTANT:exp
                        {:
                            System.out.println("Elemento agregado: " + exp);
                            RESULT = exp;
                        :};
float_expression_list ::= IDENTIFIER:id
                        {:
                            System.out.println("Elemento agregado: " + id);
                            RESULT = id;
                        :};
float_expression_list ::= FLOAT_CONSTANT:exp COMMA float_expression_list:list
                        {:
                            System.out.println("Sumando FLOAT: " + exp + " A lista: " + list);
                            RESULT = exp + ", " + list;
                        :};
float_expression_list ::= IDENTIFIER:id COMMA float_expression_list:list
                        {:
                            System.out.println("Sumando ID: " + id + " A lista: " + list);
                            RESULT = id + ", " + list;
                        :};


variable_declaration_list ::= variable_declaration variable_declaration_list | COMMENT variable_declaration_list | ;

variable_declaration ::= identifier_list:list COLON type:type {:
    System.out.println("[Var Declaration] " + list + " : " + type);
    for (String id : (ArrayList<String>) list) {
        id = id.trim();
        if (!SymbolTableGenerator.isVariableDefined(id)) {
            SymbolTableGenerator.addVariable(id, type.toString());
        }
    }
:};


identifier_list ::= IDENTIFIER:id {:
    System.out.println("Id: " + id);
    List<String> ids = new ArrayList<>();
    ids.add(id.toString().trim());


    RESULT = ids;
:};

identifier_list ::= identifier_list:list COMMA IDENTIFIER:id {:
    System.out.println("List: " + list + ", ID: " + id);
    ((List<String>) list).add(id.toString().trim());
    RESULT = list;
:};

type ::= FLOAT_TYPE {: System.out.println("Float"); RESULT = "float"; :}
      | INT {: System.out.println("Int"); RESULT = "int"; :}
      | STRING {: System.out.println("String"); RESULT = "string"; :};

comparison ::= expression:exp1 GREATER_THAN expression:exp2 {:
    nComp = NodoSintactico.crearNodo(">", exp1, exp2);
    RESULT = nComp;
:};

comparison ::= expression:exp1 LESS_THAN expression:exp2 {:
    nComp = NodoSintactico.crearNodo("<", exp1, exp2);
    RESULT = nComp;
:};

comparison ::= expression:exp1 EQUALS expression:exp2 {:
    nComp = NodoSintactico.crearNodo("==", exp1, exp2);
    RESULT = nComp;
:};

// Comparison with AND
comparison ::= comparison:comp AND expression:exp1 GREATER_THAN expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo(">", exp1, exp2);
    nComp = NodoSintactico.crearNodo("AND", comp, comp2);
    RESULT = nComp;
:};

comparison ::= comparison:comp AND expression:exp1 LESS_THAN expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo("<", exp1, exp2);
    nComp = NodoSintactico.crearNodo("AND", comp, comp2);
    RESULT = nComp;
:};

comparison ::= comparison:comp AND expression:exp1 EQUALS expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo("==", exp1, exp2);
    nComp = NodoSintactico.crearNodo("AND", comp, comp2);
    RESULT = nComp;
:};

// Comparison with OR
comparison ::= comparison:comp OR expression:exp1 GREATER_THAN expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo(">", exp1, exp2);
    nComp = NodoSintactico.crearNodo("OR", comp, comp2);
    RESULT = nComp;
:};

comparison ::= comparison:comp OR expression:exp1 LESS_THAN expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo("<", exp1, exp2);
    nComp = NodoSintactico.crearNodo("OR", comp, comp2);
    RESULT = nComp;
:};

comparison ::= comparison:comp OR expression:exp1 EQUALS expression:exp2 {:
    NodoSintactico comp2 = NodoSintactico.crearNodo("==", exp1, exp2);
    nComp = NodoSintactico.crearNodo("OR", comp, comp2);
    RESULT = nComp;
:};

// Comparison with NOT
comparison ::= NOT expression:exp1 GREATER_THAN expression:exp2 {:
    NodoSintactico comp = NodoSintactico.crearNodo(">", exp1, exp2);
    nComp = NodoSintactico.crearNodo("NOT", comp, null);
    RESULT = nComp;
:};

comparison ::= NOT expression:exp1 LESS_THAN expression:exp2 {:
    NodoSintactico comp = NodoSintactico.crearNodo("<", exp1, exp2);
    nComp = NodoSintactico.crearNodo("NOT", comp, null);
    RESULT = nComp;
:};

comparison ::= NOT expression:exp1 EQUALS expression:exp2 {:
    NodoSintactico comp = NodoSintactico.crearNodo("==", exp1, exp2);
    nComp = NodoSintactico.crearNodo("NOT", comp, null);
    RESULT = nComp;
:};

comparison ::= expression:exp1 {:
    System.out.println("Comparison: " + exp1);
    nComp=exp1;
    RESULT = nComp;
:};

expression ::= term:exp {: nExp = nTerm;
                            RESULT = nExp;
                         :};
expression ::=  expression:exp1 PLUS term:exp2 {:
                System.out.println(exp1 + " + " + exp2);
                nExp = NodoSintactico.crearNodo("+",(NodoSintactico)nExp,(NodoSintactico)nTerm);
                RESULT = nExp;
            :};
expression ::= expression:exp1 SUB term:exp2 {:
                System.out.println(exp1 + " - " + exp2);
                nExp = NodoSintactico.crearNodo("-",(NodoSintactico)nExp,(NodoSintactico)nTerm);
                RESULT = nExp;
               :};

term ::= factor:exp {: nTerm = nFactor;
                        RESULT = nTerm;
                    :};
term ::= term:exp1 MULT factor:exp2 {:
            System.out.println(exp1 + " * " + exp2);
            nTerm = NodoSintactico.crearNodo("*",(NodoSintactico)nTerm,(NodoSintactico)nFactor);
            RESULT = nTerm;
         :};
term ::= term:exp1 DIV factor:exp2 {:
           System.out.println(exp1 + " / " + exp2);
           nTerm = NodoSintactico.crearNodo("/",(NodoSintactico)nTerm,(NodoSintactico)nFactor);
           RESULT = nTerm;
         :};

factor ::= IDENTIFIER:id {: System.out.println("Id: " + id); nFactor = NodoSintactico.crearHoja(id); RESULT=nFactor;:};
factor ::= INTEGER_CONSTANT:constant {:
            System.out.println("Constant: " + constant);
            String value = constant.toString();
            SymbolTableGenerator.addConstant(value, "int", value);
            nFactor = NodoSintactico.crearHoja(constant);
            RESULT=nFactor;
            :};

factor ::= FLOAT_CONSTANT:constant {:
            System.out.println("Constant: " + constant);
            String value = constant.toString();
            SymbolTableGenerator.addConstant(value, "float", value);
            nFactor = NodoSintactico.crearHoja(constant);
            RESULT=nFactor;
            :};

factor ::= STRING_LITERAL:literal {:
            System.out.println("String literal: " + literal);
            String value = literal.toString();
            SymbolTableGenerator.addConstant(value, "string", value);
            nFactor = NodoSintactico.crearHoja(literal);
            RESULT=nFactor;
            :};

factor ::= OPEN_PARENTHESES expression:exp CLOSE_PARENTHESES {: System.out.println("Expression: (" + exp + ")"); nFactor = nExp; RESULT=nFactor; :};

bool_expression ::= INTEGER_CONSTANT:integer_constant
        {:
          if (!integer_constant.equals("0") && !integer_constant.equals("1")) {
            throw new Exception("Invalid boolean constant: " + integer_constant);
          }
          RESULT = integer_constant;
        :};